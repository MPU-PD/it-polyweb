\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\geometry{top=2cm, bottom=2cm, left=2.5cm, right=2.5cm}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{enumitem}

\titleformat{\section}{\bfseries\Large}{}{0em}{}
\titleformat{\subsection}{\bfseries\large}{}{0em}{}

\newcommand{\ProjectMembers}{Вышиванова Софья Олеговна, Горбач Иван Витальевич, Демченко Егор Максимович, Жаков Роман Сергеевич, Исаев Иван Владиславович, Карпов Денис Александрович, Кожеров Михаил Владимирович, Козлов Данил Евгеньевич, Кочетова Александра Павловна, Кувшинников Никита Владимирович, Кузнецов Дмитрий Александрович, Лунин Иван Александрович, Пономарева Алина Евгеньевна, Родванский Олег Станиславович, Савельева Мария Дмитриевна, Томашева Анна Владимировна, Фаттахова Алина Рафиковна, Федорова Диана Кирилловна, Шатилов Яков Григорьевич, Шахно Анастасия Игоревна, Щукин Максим Александрович, Ялтанцева Ирина Григорьевна}

\begin{document}

\section*{Партнер/заказчик проекта}
\textbf{Название организации:} ФГАOУ ВО «Московский политехнический университет»\\
\textbf{Контактное лицо:} Даньшина Марина Владимировна

\section*{Введение}
В современном мире эффективность и стандартизация документации являются важными аспектами успешной деятельности организаций. Многие компании и образовательные учреждения требуют строгого соблюдения стандартов оформления документов, таких как ГОСТ. Ручное форматирование документов занимает много времени и часто приводит к ошибкам, что снижает производительность и может негативно сказываться на качестве.

\section{Актуальность и проблематика проекта}
Многие пользователи, будь то студенты, научные сотрудники или специалисты по документообороту, сталкиваются с проблемой оформления документов в строгом соответствии с ГОСТ и другими стандартами. Ручной процесс форматирования занимает значительное время и подвержен ошибкам, что может приводить к задержкам и неудовлетворительным результатам. Сервис ГОСТДОК позволяет автоматизировать этот процесс, сокращая время на форматирование и улучшая его качество.

Исследование, проведенное со стейкхолдерами, показало, что пользователи часто сталкиваются с проблемами форматирования заголовков, таблиц, изображений, а также с необходимостью соблюдения стандартов, таких как ГОСТ. Это подтверждает актуальность задачи автоматизации форматирования документов. Также были выявлены проблемы с ошибками компиляции и синтаксическими ошибками, связанными с LaTeX, что требует улучшенной диагностики и поддержки отладки.

\section{Участники проекта}
\ProjectMembers

\newpage

\section{2 Суть проекта, цели, задачи, этапы реализации}
Суть проекта: ГОСТДОК — это веб-сервис, который позволяет автоматически форматировать документы по стандартам ГОСТ и другим требуемым шаблонам с использованием LaTeX или через удобный веб-интерфейс.

\section{Цели проекта:}
  \begin{enumerate}
    \item Создать сервис для автоматического форматирования документов по ГОСТ;
    \item Обеспечить доступ к высококачественной верстке документов для пользователей с разным уровнем подготовки;
    \item Решить проблемы, выявленные в ходе исследования со стейкхолдерами, связанные с форматированием, ошибками компиляции и сложностью использования LaTeX.
\end{enumerate}

\section{Задачи проекта:}
 \begin{enumerate}
    \item Разработка веб-приложения с функционалом автоматического форматирования;
    \item Интеграция с LaTeX для обеспечения высококачественной верстки документов;
    \item Создание пользовательского интерфейса для удобства работы без опыта работы с LaTeX;
    \item Поддержка различных шаблонов и стандартов, включая ГОСТ;
    \item Обеспечение экспорта документов в популярных форматах (PDF);
    \item Поддержка вставки сложных элементов, таких как изображения, таблицы, графические элементы и библиографии;
    \item Обеспечение автоматической проверки синтаксиса и подсказок для исправления ошибок.
 \end{enumerate}

 \section{Этапы реализации:}
 \begin{enumerate}
    \item Анализ требований и разработка концепции.
    \item Проведение исследования со стейкхолдерами и аналитики по проекту.
    \item Создание архитектуры веб-приложения.
    \item Разработка пользовательского интерфейса и интеграция с LaTeX.
    \item Тестирование и исправление ошибок.
    \item Запуск сервиса и получение обратной связи от пользователей.
    
 \end{enumerate}
 
\newpage

\section{3 Описание полученных результатов выполненных задач}
\begin{enumerate}
    \item Разработан базовый веб-интерфейс для пользователя, который включает в себя регистрацию и управление личными документами;
    \item Интегрирована возможность загрузки и компиляции текста в PDF с использованием LaTeX;
    \item Создан каталог шаблонов, поддерживающий стандарты ГОСТ и другие;
    \item Добавлена поддержка вставки изображений, таблиц и работы с библиографией, что помогает пользователям проще работать с документами, соответствующими стандартам;
    \item Реализована функция автоматической проверки синтаксиса и предоставления подсказок для устранения ошибок.
    
 \end{enumerate}

\section{4 Промежуточный продуктовый результат. На данном этапе реализации проекта достигнуты следующие ключевые результаты:}
\begin{description}
    \item 1.	Проработка концепции веб-приложения:
    \item - проведено исследование, на основе которого сформированы основные требования к проекту;
    \item - определены задачи, направленные на создание функционального и удобного в использовании приложения.


    \item 2.	Документация:

    \item - созданы LaTeX-шаблоны для подготовки отчетной документации, соответствующей стандартам Центра проектной деятельности по дисциплине «Проектная деятельность»;

    \item - шаблоны обеспечивают единообразие и упрощают процесс подготовки отчетов.

    \item 3.	Архитектура системы:
    \item - Разработана и спроектирована архитектура веб-приложения, учитывающая масштабируемость и удобство интеграции новых функций.
    \item 4.	Реализация серверной части:
    \item - Серверная логика реализована на языке программирования Python с использованием фреймворка FastAPI, который обеспечивает высокую производительность, читаемость кода и простоту развертывания.
    \item 5.	Разработка пользовательского интерфейса:
    \item - созданы основные страницы веб-интерфейса приложения;
    \item - для разработки клиентской части использованы современные технологии JavaScript и React, что позволяет добиться высокой интерактивности и адаптивности пользовательского интерфейса.

\newpage
    \item 6.	Интеграция и взаимодействие компонентов:
    \item - Обеспечена интеграция серверной и клиентской частей, что позволяет приложению функционировать в режиме реального времени и эффективно взаимодействовать с пользователями.
\end{description}
\section{Заключение}
Проект ГОСТДОК направлен на решение проблемы автоматического форматирования документов в соответствии со стандартами ГОСТ и другими требуемыми шаблонами. На данный момент достигнуты значительные успехи в анализе потребностей пользователей и разработке концепции сервиса. В ходе исследования со стейкхолдерами были выявлены ключевые проблемы пользователей, такие как сложности с форматированием, ошибки компиляции и неудобства интерфейса. Эти проблемы решаются в рамках проекта за счет автоматического форматирования, интерактивного редактора с подсказками и поддержки сложных элементов.

\section{Планы дальнейшей работы:}
\begin{description}
    \item {- расширение функциональности приложения;}
    \item {- проведение тестирования для выявления и устранения ошибок;}
    \item {- оптимизация производительности;}
    \item {- подготовка итоговой документации и развертывание приложения в эксплуатацию.}
\end{description}  
\section{Список использованных источников}
    \begin{enumerate}
    
    \item Лампорт Л. LaTeX: система подготовки документов. Пользовательская документация. – М.: Вильямс, 2019. – 600 с.
    \item Статьи и публикации на Overleaf.com. Современные практики использования LaTeX в веб-среде [Электронный ресурс]. – Режим доступа: https://www.overleaf.com/

 \end{enumerate}

\newpage
\section*{Щукин Максим Александрович(231-339)(Бэкэнд) }
\section*{Написание скрипта на языке Python для базовой работы с Minio.}
MinIO — это высокопроизводительный объектный хранилище, совместимое с API Amazon S3. В Python для работы с MinIO можно использовать библиотеку minio, которая позволяет легко загружать, скачивать и управлять объектами в хранилище. С помощью методов этой библиотеки можно создавать бакеты, загружать файлы и получать доступ к метаданным объектов, что делает интеграцию с MinIO простой и эффективной.

\section{Необходимый функционал:}
\begin{description}
    \item 1) Возможность сохранить/обновить файл
    \item 2) Возможность получить файл
\end{description}
\section{Реализация (листинг в приложении(возможно)):}
   Для работы с MinIO в Python необходимо установить библиотеку minio с помощью команды pip install minio. Затем можно создать клиент MinIO, указав URL сервера, ключ доступа и секретный ключ. Используя методы клиента, можно выполнять операции, такие как создание бакета (make\_bucket), загрузка объектов (send\_file) и получение объектов (get\_file).
\begin{description}
   \item def send\_file(bucket, source, destination):
        \item \hspace{10mm}  fi os.path.isfile (source):
        \item \hspace{15mm}   pass
        \item \hspace{10mm}   else:
        \item \hspace{15mm}  open(source, "x")
        \item \hspace{10mm}   client.fput\_object(
        \item \hspace{15mm}  bucket, destination, source
        \item \hspace{10mm}  )
        \item \hspace{10mm}  print(
        \item \hspace{15mm}  source, "successfully uploaded as object",
        \item \hspace{15mm}  destination, "to bucket", bucket,
        \item \hspace{10mm}  )
        \item \hspace{10mm}  def get\_file(bucket, source, destination):
        \item \hspace{15mm}  if os.path.isfile (source):
        \item \hspace{20mm}   pass

\newpage
        \item \hspace{15mm}    else:
        \item \hspace{10mm}   open(source, "w")
        \item \hspace{15mm}     client.fget\_object(
        \item \hspace{10mm}    bucket, destination, source
        \item \hspace{15mm}      )
        \item \hspace{15mm}     print(destination\_file, "successfully uploaded as file", source)
    \vspace{5mm}
    \item Файлы для приложения
    \item (https://drive.google.com/file/d/14Ntd2dicPc802QMZohHKVG50UfdGOojs/view?usp=drive\_link)
    \end{description}
    \section{Конвертация LaTex в PDF посредством Python.}
    Для написания кода в LaTex был использован компилятор MikTex, с его помощью был создан “.tex” файл для дальнейшего его преобразования в PDF посредством Python используя библиотеку subprocess и выполнить команду pdflatex имя\_файла.tex, чтобы сгенерировать PDF.
    Таким образом было проведено тестирование возможностей языка по преобразованию, а также написан скрипт для преобразования файла.
\begin{description}
    \item Файлы для приложения
    \item (https://drive.google.com/file/d/1x10ApVvWiF8Cf9SKWE2oDRWtIq1EwxL7/view?usp=drive\_link)
    \section{Тестирование эндпоинтов project}
    \item Целью данного тестирования было проверить функциональность и надежность эндпоинтов API, а также выявить возможные ошибки и проблемы в работе системы перед ее запуском.
 \end{description}
    \section{Сценарии тестирования:}
    
    \begin{description}
    \item \hspace{5mm}1)	Создание проекта (POST/ projects)
    \item \hspace{10mm}- Ожидаемый результат: Статус 200, проект создан.
    \item \hspace{10mm} - Полученный результат: Статус 200, проект создан.

    \item \hspace{5mm}2) Получение списка проектов (GET/ projects)
    \item \hspace{10mm}- Ожидаемый результат: Статус 200, {список проектов пользователя}
    \item \hspace{10mm}- Полученный результат: Статус 200, {список проектов пользователя}
    \item Данные сценарии были проведены трижды. Во второй итерации была получена ошибка 422
    \item Отчёт об ошибке был составлен и причины ошибки были устранены.
    \item Тестирование эндпоинтов Project показало, что они функционируют корректно и отвечают требованиям.
\end{description}
\newpage

\section*{Кожеров Михаил Владимирович (231-339)}

\section*{Написание скрипта на языке Python для загрузки файлов на сервер}

Задача заключается в написании кода, который будет принимать файлы от клиента и сохранять их (хотя в данном примере сохранение файла не требуется, только обработка и вывод данных). Этот код будет частью более крупного сервера (веб-сервера, например). "Тестовый" означает, что это упрощенная версия, предназначенная для проверки функциональности, без лишних функций безопасности или масштабирования.

\subsection*{Эндпоинт: PUT /test/upload}
Это адрес, по которому клиент будет отправлять файлы.

\begin{itemize}
    \item PUT -- это HTTP-метод, используемый для обновления или замены ресурса (в данном случае файла).
    \item /test/upload -- это путь к обработчику на сервере. Это часть URL-адреса, который будет указываться в запросе.
\end{itemize}

Файл должен загружаться через form-data: Это указывает на способ отправки файла. form-data -- это кодировка данных в HTTP-запросе, которая позволяет передавать файлы вместе с другими данными (например, полями формы). Это распространенный стандарт для отправки файлов через веб-формы.

Хендлер должен выводить имя загруженного файла и его содержимое: Это описание ожидаемого результата работы хендлера. После успешной загрузки файла, сервер должен вернуть клиенту информацию о загруженном файле: его имя и содержимое (в виде текста, если файл текстовый; для бинарных файлов потребуется более сложное представление). Это обычно делается в формате JSON для удобства обработки ответа клиентом.

\begin{verbatim}
from typing import Annotated
from fastapi import FastAPI, File, UploadFile

app = FastAPI()

@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}

@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}
\end{verbatim}

\section*{Тестирование эндпоинтов user}

\subsection*{Тест-кейс Create User}

\subsubsection*{Сценарий 1: регистрация пользователя (POST /user/sign up)}
Ожидание: выдаст код 200

Реальность: код 200



\subsubsection*{Сценарий 2: регистрация пользователя при некорректных данных (POST /user/signup)}
Ожидание: выдаст код 422

Реальность: код 422



\subsection*{Тест-кейс Sign In}

\subsubsection*{Сценарий 1: авторизация пользователя (POST /user/sign in)}
Ожидание: выдаст код 200

Реальность: код 200



\subsubsection*{Сценарий 2: авторизация пользователя при некорректных данных (POST /user/sign in)}
Ожидание: выдаст код 422

Реальность: код 422



\subsubsection*{Сценарий 3: авторизация пользователя при некорректных email (POST /user/sign in)}
Ожидание: выдаст код 422

Реальность: код 200



\subsection*{Тест-кейс Refresh User Token}

\subsubsection*{Сценарий 1: проверка Refresh User Token (POST /user/refresh)}
Ожидание: выдаст код 200

Реальность: код 200



\subsubsection*{Сценарий 2: проверка с Access User Token (POST /user/refresh)}
Ожидание: выдаст код 422

Реальность: код 200



\newpage

\section{Исаев Иван Владиславович  (231-339)(Бэкэнд) Задача 1: Создание refresh-token handler’а.}

Теория:
"Handler" (обработчик) — это функция или метод, который предназначен для обработки определённого события или запроса. Он выступает в роли посредника между источником события и логикой приложения, обеспечивая реакцию на действия пользователя или изменения состояния системы. Например, в графических интерфейсах пользователя (GUI) обработчики событий могут реагировать на действия, такие как нажатия кнопок, ввод данных или перемещение мыши, выполняя соответствующие действия, такие как обновление интерфейса или выполнение вычислений. В контексте веб-разработки обработчики могут управлять HTTP-запросами, обрабатывая данные, поступающие от клиента, и возвращая соответствующие ответы. Использование обработчиков позволяет организовать код более структурированно, улучшая его читаемость и поддерживаемость, а также обеспечивая модульность и переиспользуемость логики обработки событий.

Refresh token — это специальный токен, используемый в системах аутентификации для получения нового access token (токена доступа) без необходимости повторного ввода учетных данных пользователя. Обычно refresh token выдается вместе с access token и имеет более длительный срок действия. Когда access token истекает, приложение может использовать refresh token для запроса нового access token у сервера, что позволяет обеспечить непрерывный доступ к защищенным ресурсам без необходимости повторной аутентификации пользователя. Это повышает удобство использования и безопасность, так как access token может иметь короткий срок действия, минимизируя риск его компрометации, в то время как refresh token хранится в безопасном месте и используется только для получения новых access token.

Access token (токен доступа) — это временный цифровой ключ, который используется для аутентификации и авторизации пользователя при доступе к защищенным ресурсам, таким как API или веб-приложения. Он выдается сервером аутентификации после успешной проверки учетных данных пользователя и позволяет пользователю взаимодействовать с ресурсами без необходимости повторного ввода логина и пароля. Access token обычно имеет ограниченный срок действия, что повышает безопасность, так как даже в случае его компрометации злоумышленник будет иметь доступ только на короткий период времени. Токен содержит информацию о пользователе и его правах доступа, что позволяет серверу быстро и эффективно проверять, имеет ли пользователь право на выполнение определенных действий.
Практика:
Для начала я прочитал статью на Хабре для того, чтобы лучше понимать структуру кода и осознавать, какую роль должен выполнять мой handler кроме выдачи пользователю нового access-token’a. (ссылка на статью: https://habr.com/ru/companies/doubletapp/articles/764424/)
После этого я открыл Pycharm и выполнил свою задачу.

\section*{}
\begin{description}
 \item import os
 \item import secrets

 \item from jose import JWTError, jwt
 \item from datetime import datetime, timedelta
 \item from dotenv import load\_dotenv

 \item load\_dotenv()
 \item secret\_key = os.getenv("SECRET\_KEY")


 \item def create\_access\_token(data: dict, expires\_delta: timedelta = timedelta(days=1)):
 	\item \hspace{10mm} to\_encode = data.copy()
 	\item \hspace{10mm} expire = datetime.utcnow() + expires\_delta
 	\item \hspace{10mm} to\_encode.update({"exp": expire})
 	\item \hspace{10mm} return jwt.encode(to\_encode, secret\_key, algorithm="HS256")


 \item def create\_refresh\_token(data: dict, expires\_delta: timedelta = timedelta(days=30)):
 	\item \hspace{10mm}to\_encode = data.copy()
 	\item \hspace{10mm} expire = datetime.utcnow() + expires\_delta
 	\item \hspace{10mm} to\_encode.update({"exp": expire})
 	\item \hspace{10mm} return jwt.encode(to\_encode, secret\_key, algorithm="HS256")


 \item def refresh\_access\_token(refresh\_token: str):
 	\item \hspace{10mm} try:
         \item \hspace{20mm} payload = jwt.decode(refresh\_token, secret\_key, algorithms=["HS256"])
     	\item \hspace{20mm} username = payload.get("sub")

     	\item \hspace{20mm} if username is None:
         	\item \hspace{20mm} raise JWTError("Invalid refresh token")

     	\item \hspace{20mm} new\_access\_token = create\_access\_token(data={"sub": username})
     	\item \hspace{20mm} return new\_access\_token
 	\item \hspace{10mm} except JWTError:
     	\item \hspace{10mm} raise JWTError("Could not validate refresh token")
\end{description}
Затем я выложил дополненный вариант jwt.py в репозиторий проекта на Github.
\section*{Задача 2: QA тестирование endpoint’ов document. }
В документации (https://gostdocapi.computernetthings.ru/docs) найти все эндпоинты из группы document и протестировать работоспособность через postman или любой аналог.

QA (Quality Assurance) тестирование — это процесс, направленный на обеспечение качества программного продукта путем систематической проверки его функциональности, производительности, безопасности и удобства использования. QA-тестировщики проверяют программное обеспечение на наличие ошибок и несоответствий требованиям, а также оценивают его соответствие стандартам качества. В процессе тестирования могут использоваться различные методологии, такие как ручное тестирование, автоматизированное тестирование, функциональное и регрессионное тестирование, что позволяет выявить дефекты на различных этапах разработки. Основная цель QA — обеспечить, чтобы конечный продукт соответствовал ожиданиям пользователей и был свободен от критических ошибок, которые могут негативно сказаться на его работе.

Кроме того, QA-тестирование включает в себя не только выявление ошибок, но и анализ процессов разработки для их улучшения. Тестировщики могут давать рекомендации по оптимизации рабочих процессов, выявляя узкие места и предлагая решения для повышения эффективности команды. QA-тестирование также включает в себя создание документации, такой как тестовые планы и отчеты о тестировании, что помогает команде разработки лучше понимать выявленные проблемы и отслеживать их решение. В конечном итоге, качественное тестирование способствует повышению доверия пользователей к продукту и уменьшению затрат на исправление ошибок после его релиза.

Практика:

Тестирование проводилось в 3 цикла (т.е. рутинная проверка раз в неделю).. Ниже приведены только уникальные сценарии, повторяющиеся сценарии опущены и описаны в первом уникальном случае.

Сценарий 1: Создание документа POST/documents/create, Цикл 1
Ожидание: Успешное создание документа, код 200.
Результат: “ MinioStorage’ object has no attribute ‘copy\_object‘ “, ошибка метода. Код: 500, Internal server error.

Сценарий 2: Создание документа POST/documents/create, Цикл 2
Ожидание: Успешное создание документа, код 200.
Результат: Успешное создание документа, код 200.

Сценарий 3: GET/documents/{Id}/compile без валидных данных, циклы 1 и 2.
Ожидание: Код 200, обработанная ошибка 404.
Результат: Код 404, not found

Сценарий 4: GET/documents/{Id}/compile без валидных данных, цикл 3.
Ожидание: Код 200, обработанная ошибка 404.
Результат: Код 200, обработанная ошибка 404.


\newpage
\section*{Горбач Иван Витальевич 231-327 (Бэкэнд)}

\subsection*{Задача №1. Авторизация пользователей}
Для реализации авторизации пользователей был добавлен хендлер \texttt{/user/signin}. Хендлер принимает имя пользователя и пароль через JSON-запрос. Полученный пароль проверяется с использованием хеша, который хранится в базе данных. Для этого используется библиотека, обеспечивающая сравнение введенного пароля с хешем.

После успешной проверки генерируется два JWT-токена:
\begin{itemize}
    \item \textbf{Access JWT}, который содержит поля \texttt{email} и \texttt{sub} (где \texttt{sub} — идентификатор пользователя). Токен имеет время истечения 1 день.
    \item \textbf{Refresh JWT}, который содержит поле \texttt{sub} и имеет время истечения 30 дней.
\end{itemize}

В результате выполнения хендлера пользователю возвращаются Access JWT и Refresh JWT в формате JSON.

\subsection*{Задача №2. Добавление работы с темплейтами}
Для работы с темплейтами была добавлена возможность создавать файлы из шаблонов, которые хранятся в бакете \texttt{templates} системы хранения MiniO. Реализован соответствующий функционал в хендлере \texttt{POST /document/create}.

Хендлер принимает \texttt{id} проекта и имя темплейта. Логика работы хендлера выглядит следующим образом:
\begin{itemize}
    \item Если передано имя темплейта:
    \begin{itemize}
        \item Файл темплейта копируется из бакета \texttt{templates} в бакет пользовательских файлов \texttt{userdata}.
        \item Новый файл создается с уникальным именем в формате \texttt{[uuid].tex} (например, \texttt{fe1be3a7-5542-4bfb-89fa-a331b78e7151.tex}).
        \item В базу данных добавляется запись о новом файле, привязанном к проекту.
    \end{itemize}
    
    \item Если имя темплейта не передано:
    \begin{itemize}
        \item Выполняется стандартное создание пустого файла.
    \end{itemize}
\end{itemize}

\subsection*{Задача №3. Исправление работы хендлера SignIn}
Хендлер \texttt{/user/signin} не работал из-за ошибки при генерации токенов. Проблема заключалась в том, что методы \texttt{create\_access\_token} и \texttt{create\_refresh\_token} принимали объекты SQLModel, которые не могли быть сериализованы в JSON.

Для исправления проблемы была выполнена следующая работа:
\begin{itemize}
    \item Разделены DTO для \texttt{SignIn} и \texttt{SignUp}, что позволило устранить ошибку сериализации.
    \item Логика проверки входных данных изменена с использования \texttt{username} на \texttt{email}.
\end{itemize}

В результате внесенных изменений хендлер \texttt{/user/signin} корректно обрабатывает запросы и возвращает токены.

\section*{Савельева Мария Дмитриевна 231-334 (Дизайн)}
По заданию я создала вайрфрейм редактора личного кабинета, сделала необходимые правки и позже разработала сам макет.

Интерфейс настроек личного кабинета позволяет пользователю:
\begin{itemize}
    \item Увидеть и отредактировать логин, почту, пароль, описание, аватар.
    \item Удалить учетную запись и все данные, связанные с ней, если пользователь больше не планирует пользоваться услугами платформы.
\end{itemize}

\subsection*{Правки панели инструментов в редакторе документа}
\begin{itemize}
    \item \textbf{До:} [Описание или изображение старого интерфейса]
    \item \textbf{После:} [Описание или изображение нового интерфейса]
\end{itemize}

\subsection*{Вайрфрейм/макет редактора}
[Описание или изображение вайрфрейма/макета редактора]


\newpage

\section*{Никита Кувшинников (231-161)}
\section*{Улучшение функционала редактора документов}
В рамках улучшения функционала редактора документов я добавил возможность печати текста в редакторе, что не было реализовано в предыдущей версии. Также была добавлена функция форматирования текста, которая включает такие опции, как изменение шрифта, его размера, выделение жирным, курсивом и подчеркиванием. Это значительно расширило возможности работы с текстом и улучшило пользовательский опыт.

\subsection*{Компонент Editor.jsx}
[language=JavaScript]

\begin{description}

\item import { useRef } from "react";
\item import "../../scss/custom/Editor.scss";

\item const Editor = ({
  \item fontFamily,
  \item fontSize,
  \item onWordCountChange,
  \item fontWeight,
  \item textDecoration,
  \item fontStyle,
\item }) => {
  \item const editorRef = useRef(null);

  \item // Обработчик изменения текста
  \item const handleTextChange = () => {
    \item const newText = editorRef.current.innerText;
  
  \item };

  \item return (
    \item <div>
      \item <div
        \item className="document"
        \item contentEditable={true}
        \item ref={editorRef}
        \item style=\{\{
          \item fontFamily: fontFamily,
          \item fontSize: `\${fontSize}px`,
          \item fontWeight: fontWeight,
          \item fontStyle: fontStyle,
          \item textDecoration: textDecoration,
          \item direction: "ltr",
          \item whiteSpace: "pre-wrap",
          \item color: "black",
        \item \}\}
        \item onInput={handleTextChange}
      \item />
    \item </div>
  \item );
\item };

export default Editor;
\end{description}

И подготовил данные для отправки запросов на создание нового документа, что упрощает пользователям создание документов и улучшает взаимодействие с серверной частью приложения.

\section*{Доработки компонентов и стилей}
Я провел доработку компонентов и стилей для улучшения интерфейса и удобства использования. В частности, добавил динамический \texttt{header}, который изменяется в зависимости от состояния страницы или действий пользователя, что помогает сделать навигацию более интуитивной. Также были подправлены стили страницы регистрации, чтобы сделать её более удобной и визуально приятной.

\subsection*{Компонент Header.jsx}

[language=JavaScript]
\begin{description}
\item import React from "react";
\item import { Link, useLocation } from "react-router-dom";
\item import { ReactComponent as HomeIcon } from "../assets/icons/iconHome.svg";
\item import { ReactComponent as PlusIcon } from '../assets/icons/iconPlus.svg';
\item import "../scss/custom/header.scss";
\item import Search from "./basic/Search.jsx";
\item import Button from "./basic/Button.jsx";
\item import iconUser from '../assets/icons/iconUser.svg';
\item import uploadIcon from '../assets/icons/iconUpload.svg';

\item const Header = () => {
  \item const location = useLocation();
  \item const isDocsPage = location.pathname === "/docs";
  \item const isEditorPage = location.pathname === "/editor";

  \item return (
    \item <header className="header">
      \item <div className="header\_\_static">
        \item <Link to="/docs" className="header\_\_home">
          \item <HomeIcon
            \item style={{
              \item fill: "rgb(245, 245, 245)",
              \item width: "14px",
              \item height: "14px",
            \item }}
          \item />
        \item </Link>
        \item <Search placeholder={isDocsPage ? 'Поиск документов' : 'Поиск'} />
      \item </div>
      \item {isDocsPage ? (
        \item <div className="header\_\_docs">
          \item <h2>Все документы</h2>
          \item <div className="header\_\_buttons">
            \item <Button modifier=" button--primary">
              \item <PlusIcon />
              \item Документ
            \item </Button>
            \item <Button modifier=" button--secondary">Загрузить</Button>
          \item </div>
        \item </div>
      \item ) : isEditorPage ? (
        \item <div className="header\_\_editor">
          \item <div className="header\_\_nameless-wrapper">
            \item <h2 className="header\_\_name-doc">Документ 3</h2>
            \item <button className="header\_\_upload-button"><img className="header\_\_upload-image" 
            \item src={uploadIcon} alt="Загрузить"></img></button>
          \item </div>
          \item <div className="header\_\_buttons">
            \item <img className="header\_\_user-image" src={iconUser} alt="Иконка пользователя"></img>
            \item <Button modifier=" button--primary">Поделиться</Button>
          \item </div>
        \item </div>
      \item ) : null}
    \item </header>
  \item );
\item };

\item export default Header;
\end{description}

\section*{Помощь фронтенд-разработчикам}
Помимо собственных задач, я активно помогал другим фронтенд-разработчикам команды. Проводил ревью их кода, помогал выявлять и исправлять баги, а также чинил конфликты при слиянии различных веток разработчиков в общий проект. Это помогло обеспечить стабильность проекта и ускорить интеграцию новых функциональных возможностей.



\end{document}



\end{document}